/* The Computer Language Benchmarks Game
http://shootout.alioth.debian.org/

contributed by James McIlree
 */
package de.tlabs.thinkAir.benchmarkBundle2;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.InputStreamReader;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import de.tlabs.thinkAir.benchmarkBundle1.Benchmark;
import de.tlabs.thinkAir.lib.ExecutionController;
import de.tlabs.thinkAir.lib.Remote;
import de.tlabs.thinkAir.lib.Remoteable;

/**
 * We use FASTA files generated by the fasta benchmark as input for this
 * benchmark. Note: the file may include both lowercase and uppercase codes.<br/>
 * 
 * Each program should:
 * <ul>
 * <li>read line-by-line a redirected FASTA format file from stdin</li>
 * <li>extract DNA sequence THREE</li>
 * <li>define a procedure/function to update a hashtable of k-nucleotide keys
 * and count values, for a particular reading-frame — even though we'll combine
 * k-nucleotide counts for all reading-frames (grow the hashtable from a small
 * default size)</li>
 * <li>use that procedure/function and hashtable to
 * <ul>
 * <li>count all the 1-nucleotide and 2-nucleotide sequences, and write the code
 * and percentage frequency, sorted by descending frequency and then ascending
 * k-nucleotide key</li>
 * <li>count all the 3- 4- 6- 12- and 18-nucleotide sequences, and write the
 * count and code for the specific sequences GGT GGTA GGTATT GGTATTTTAATT
 * GGTATTTTAATTTATAGT</li>
 * </ul>
 * </li>
 * </ul>
 * 
 * In practice, less brute-force would be used to calculate k-nucleotide
 * frequencies<br />
 * 
 * Modified for PowerDroid framework by Andrius Aucinas
 * 
 * @author AndriusA
 * 
 */
public class knucleotide extends Remoteable implements Benchmark {
	/**
	 * 
	 */
	private static final long serialVersionUID = 4939564883645406299L;

	String sequence;
	int count = 1;

	private transient ExecutionController controller;

	public knucleotide(ExecutionController controller) {
		this.controller = controller;
	}

	knucleotide(String sequence) {
		this.sequence = sequence;
	}

	static ArrayList<Callable<Map<String, knucleotide>>> createFragmentTasks(
			final String sequence, int[] fragmentLengths) {
		ArrayList<Callable<Map<String, knucleotide>>> tasks = new ArrayList<Callable<Map<String, knucleotide>>>();
		for (int fragmentLength : fragmentLengths) {
			for (int index = 0; index < fragmentLength; index++) {
				final int offset = index;
				final int finalFragmentLength = fragmentLength;
				tasks.add(new Callable<Map<String, knucleotide>>() {
					public Map<String, knucleotide> call() {
						return createFragmentMap(sequence, offset,
								finalFragmentLength);
					}
				});
			}
		}
		return tasks;
	}

	static Map<String, knucleotide> createFragmentMap(String sequence,
			int offset, int fragmentLength) {
		HashMap<String, knucleotide> map = new HashMap<String, knucleotide>();
		int lastIndex = sequence.length() - fragmentLength + 1;
		for (int index = offset; index < lastIndex; index += fragmentLength) {
			String temp = sequence.substring(index, index + fragmentLength);
			knucleotide fragment = (knucleotide) map.get(temp);
			if (fragment != null)
				fragment.count++;
			else
				map.put(temp, new knucleotide(temp));
		}

		return map;
	}

	// Destructive!
	static Map<String, knucleotide> sumTwoMaps(Map<String, knucleotide> map1,
			Map<String, knucleotide> map2) {
		for (Map.Entry<String, knucleotide> entry : map2.entrySet()) {
			knucleotide sum = (knucleotide) map1.get(entry.getKey());
			if (sum != null)
				sum.count += entry.getValue().count;
			else
				map1.put(entry.getKey(), entry.getValue());
		}
		return map1;
	}

	static String writeFrequencies(Map<String, knucleotide> frequencies) {
		ArrayList<knucleotide> list = new ArrayList<knucleotide>(frequencies
				.size());
		int sum = 0;
		for (knucleotide fragment : frequencies.values()) {
			list.add(fragment);
			sum += fragment.count;
		}

		Collections.sort(list, new Comparator<knucleotide>() {
			public int compare(knucleotide o1, knucleotide o2) {
				int c = o2.count - o1.count;
				if (c == 0) {
					c = o1.sequence.compareTo(o2.sequence);
				}
				return c;
			}
		});

		StringBuilder sb = new StringBuilder();
		for (knucleotide k : list)
			sb.append(String.format("%s %.3f\n", k.sequence.toUpperCase(),
					(float) (k.count) * 100.0f / (double) sum));

		return sb.toString();
	}

	static String writeCount(List<Future<Map<String, knucleotide>>> futures,
			String nucleotideFragment) throws Exception {
		int count = 0;
		for (Future<Map<String, knucleotide>> future : futures) {
			knucleotide temp = future.get().get(nucleotideFragment);
			if (temp != null)
				count += temp.count;
		}

		return count + "\t" + nucleotideFragment.toUpperCase();
	}

	public void main(int n) {
		String line;
		ByteArrayOutputStream bout = new ByteArrayOutputStream();
		try {
			fasta generator = new fasta();
			generator.main(n, bout);
			ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray());

			InputStreamReader ir = new InputStreamReader(bin);
			
			BufferedReader in = new BufferedReader(ir);
			while ((line = in.readLine()) != null) {
				if (line.startsWith(">THREE"))
					break;
			}

			StringBuilder sbuilder = new StringBuilder();
			while ((line = in.readLine()) != null) {
				sbuilder.append(line);
			}

			System.out.print(executer(sbuilder.toString()));
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	@Remote
	private String localexecuter(String input) throws Exception {
		ExecutorService pool = Executors.newFixedThreadPool(Runtime
				.getRuntime().availableProcessors());
		int[] fragmentLengths = { 1, 2, 3, 4, 6, 12, 18 };
		List<Future<Map<String, knucleotide>>> futures = pool
				.invokeAll(createFragmentTasks(input, fragmentLengths));
		pool.shutdown();

		// Print the length 1 & 2 counts. We know the offsets of the tasks, so
		// we can cheat.
		StringBuilder out = new StringBuilder();
		out.append(writeFrequencies(futures.get(0).get()) + "\n");
		out.append(writeFrequencies(sumTwoMaps(futures.get(1).get(), futures
				.get(2).get())) + "\n");

		out.append(writeCount(futures, "ggt") + "\n");
		out.append(writeCount(futures, "ggta") + "\n");
		out.append(writeCount(futures, "ggtatt") + "\n");
		out.append(writeCount(futures, "ggtattttaatt") + "\n");
		out.append(writeCount(futures, "ggtattttaatttatagt") + "\n");

		return out.toString();
	}

	private String executer(String input) {
		Method toExecute;
		Class<?>[] paramTypes = { String.class };
		Object[] paramValues = { input };
		String result = null;
		try {
			toExecute = this.getClass().getDeclaredMethod("localexecuter",
					paramTypes);
			result = (String) controller.execute(toExecute, paramValues, this);
		} catch (SecurityException e) {
			// Should never get here
			e.printStackTrace();
			throw e;
		} catch (NoSuchMethodException e) {
			// Should never get here
			e.printStackTrace();
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public void copyState(Remoteable arg0) {
		// No need to restore any fields in this case

	}

}