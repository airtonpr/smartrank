package de.tlabs.thinkAir.benchmarkBundle2;

/*
 The Computer Language Benchmarks Game
 http://shootout.alioth.debian.org/
 contributed by Razii, idea taken from Elliott Hughes and Roger Millington
 */

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.Serializable;
import java.lang.reflect.Method;
import java.util.HashMap;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import android.util.Log;
import de.tlabs.thinkAir.benchmarkBundle1.Benchmark;
import de.tlabs.thinkAir.lib.ExecutionController;
import de.tlabs.thinkAir.lib.Remote;
import de.tlabs.thinkAir.lib.Remoteable;

/**
 * We use FASTA files generated by the fasta benchmark as input for this
 * benchmark. Note: the file may include both lowercase and uppercase codes.
 * Each program should:
 * <ul>
 * <li>read all of a redirected FASTA format file from stdin, and record the
 * sequence length</li>
 * <li>use the same simple regex pattern match-replace to remove FASTA sequence
 * descriptions and all linefeed characters, and record the sequence length</li>
 * <li>use the same simple regex patterns, representing DNA 8-mers and their
 * reverse complement (with a wildcard in one position), and (one pattern at a
 * time) count matches in the redirected file</li>
 * <li>write the regex pattern and count</li>
 * <li>use the same simple regex patterns to make IUB code alternatives
 * explicit, and (one pattern at a time) match-replace the pattern in the
 * redirect file, and record the sequence length</li>
 * <li>write the 3 recorded sequence lengths</li>
 * </ul>
 * 
 * Modified for the PowerDroid framework by Andrius Aucinas
 * 
 * @author Andrius
 * 
 */
public final class regexdna implements Benchmark, Serializable {

	/**
	 * 
	 */
	static final Map<String, String> replacements = new HashMap<String, String>();
	private transient ExecutionController controller;

	public regexdna(ExecutionController controller) {
		this.controller = controller;
	}

	static {
		replacements.put("W", "(a|t)");
		replacements.put("Y", "(c|t)");
		replacements.put("K", "(g|t)");
		replacements.put("M", "(a|c)");
		replacements.put("S", "(c|g)");
		replacements.put("R", "(a|g)");
		replacements.put("B", "(c|g|t)");
		replacements.put("D", "(a|g|t)");
		replacements.put("V", "(a|c|g)");
		replacements.put("H", "(a|c|t)");
		replacements.put("N", "(a|c|g|t)");
	}

	public void main(int n) {
		try {
			ByteArrayOutputStream bout = new ByteArrayOutputStream();
			fasta generator = new fasta();
			generator.main(n, bout);
			ByteArrayInputStream bin = new ByteArrayInputStream(bout
					.toByteArray());

			Reader r = new InputStreamReader(bin, "ISO-8859-1");
			// Change from 5100000 to n
			StringBuilder sb = new StringBuilder(n);
			char[] cbuf = new char[16384];
			int charsRead;
			while ((charsRead = r.read(cbuf)) != -1)
				sb.append(cbuf, 0, charsRead);

			int initialLength = sb.length();

			String sequence = new Rewriter2(">.*\n|\n", controller).rewrite(sb);
			System.out.println(sequence);
			int codeLength = sequence.length();

			String[] variants = { "agggtaaa|tttaccct",
					"[cgt]gggtaaa|tttaccc[acg]", "a[act]ggtaaa|tttacc[agt]t",
					"ag[act]gtaaa|tttac[agt]ct", "agg[act]taaa|ttta[agt]cct",
					"aggg[acg]aaa|ttt[cgt]ccct", "agggt[cgt]aa|tt[acg]accct",
					"agggta[cgt]a|t[acg]taccct", "agggtaa[cgt]|[acg]ttaccct" };

			Long start = System.nanoTime();
			for (String variant : variants) {

				int count = 0;
				Matcher m = Pattern.compile(variant).matcher(sequence);
				while (m.find())
					count++;
				System.out.println(variant + " " + count);
			}
			Log.d("Regexp-finder", "Time taken to find all sequences - "
					+ (System.nanoTime() - start));

			sequence = new Rewriter("[WYKMSRBDVHN]", controller)
					.rewrite(sequence);

			System.out.println();
			System.out.println(initialLength);
			System.out.println(codeLength);
			System.out.println(sequence.length());
		} catch (IOException e) {

		}

	}

}

class Rewriter extends Remoteable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 3577906245709588881L;
	protected Pattern pattern;

	transient ExecutionController controller;

	public Rewriter(String regularExpression, ExecutionController controller) {
		this.pattern = Pattern.compile(regularExpression);
		this.controller = controller;
	}

	public String group(int i, Matcher matcher) {
		return matcher.group(i);
	}

	public String replacement(Matcher m) {
		return regexdna.replacements.get(group(0, m));
	}

	public String rewrite(CharSequence original) {
		return rewrite(original, new StringBuffer(original.length()))
				.toString();
	}

	@Remote
	public StringBuffer localrewrite(CharSequence original,
			StringBuffer destination) {
		Matcher matcher = pattern.matcher(original);
		while (matcher.find()) {
			matcher.appendReplacement(destination, "");
			destination.append(replacement(matcher));
		}
		matcher.appendTail(destination);
		return destination;
	}

	@Override
	public void copyState(Remoteable arg0) {
		Rewriter remote = (Rewriter) arg0;
		this.pattern = remote.pattern;
	}

	public StringBuffer rewrite(CharSequence original, StringBuffer destination) {
		Method toExecute;
		Class<?>[] paramTypes = { CharSequence.class, StringBuffer.class };
		Object[] paramValues = { original, destination };
		StringBuffer result = null;
		try {
			// getClass() would not work with abstract class
			toExecute = Rewriter.class.getDeclaredMethod("localrewrite",
					paramTypes);
			result = (StringBuffer) controller.execute(toExecute, paramValues,
					this);
		} catch (SecurityException e) {
			// Should never get here
			e.printStackTrace();
			throw e;
		} catch (NoSuchMethodException e) {
			// Should never get here
			e.printStackTrace();
		} catch (Throwable e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return result;
	}
}

class Rewriter2 extends Remoteable {
	/**
	 * 
	 */
	private static final long serialVersionUID = 3577906245709588881L;
	protected Pattern pattern;

	transient ExecutionController controller;

	public Rewriter2(String regularExpression, ExecutionController controller) {
		this.pattern = Pattern.compile(regularExpression);
		this.controller = controller;
	}

	public String group(int i, Matcher matcher) {
		return matcher.group(i);
	}

	public String replacement(Matcher m) {
		return "";
	}

	public String rewrite(CharSequence original) {
		return rewrite(original, new StringBuffer(original.length()))
				.toString();
	}

	@Remote
	public StringBuffer localrewrite(CharSequence original,
			StringBuffer destination) {
		Matcher matcher = pattern.matcher(original);
		while (matcher.find()) {
			matcher.appendReplacement(destination, "");
			destination.append(replacement(matcher));
		}
		matcher.appendTail(destination);
		return destination;
	}

	public StringBuffer rewrite(CharSequence original, StringBuffer destination) {
		Method toExecute;
		Class<?>[] paramTypes = { CharSequence.class, StringBuffer.class };
		Object[] paramValues = { original, destination };
		StringBuffer result = null;
		try {
			// getClass() would not work with abstract class
			toExecute = Rewriter2.class.getDeclaredMethod("localrewrite",
					paramTypes);
			result = (StringBuffer) controller.execute(toExecute, paramValues,
					this);
		} catch (SecurityException e) {
			// Should never get here
			Log.e("PowerDroid-Client",
					"Problems with remoteable object implementation - reflection failures: "
							+ e);
		} catch (NoSuchMethodException e) {
			// Should never get here
			Log.e("PowerDroid-Client",
					"Problems with remoteable object implementation - reflection failures: "
							+ e);
		} catch (IllegalArgumentException e) {
			// Should never get here
			Log.e("PowerDroid-Client",
					"Problems with remoteable object implementation - reflection failures: "
							+ e);
		} catch (IllegalAccessException e) {
			// Should never get here
			Log.e("PowerDroid-Client",
					"Problems with remoteable object implementation - reflection failures: "
							+ e);
		} catch (ClassNotFoundException e) {
			// Should never get here
			Log.e("PowerDroid-Client",
					"Problems with remoteable object implementation - reflection failures: "
							+ e);
		} catch (Exception e) {
			// Must be an exception that happened in the original function
			e.printStackTrace();
		}
		return result;
	}

	@Override
	public void copyState(Remoteable arg0) {
		Rewriter2 remote = (Rewriter2) arg0;
		this.pattern = remote.pattern;
	}
}